{"ast":null,"code":"/*\n * jwt-simple\n *\n * JSON Web Token encode and decode module for node.js\n *\n * Copyright(c) 2011 Kazuhito Hokamura\n * MIT Licensed\n */\n\n/**\n * module dependencies\n */\nvar crypto = require('crypto');\n\n/**\n * support algorithm mapping\n */\nvar algorithmMap = {\n  HS256: 'sha256',\n  HS384: 'sha384',\n  HS512: 'sha512',\n  RS256: 'RSA-SHA256'\n};\n\n/**\n * Map algorithm to hmac or sign type, to determine which crypto function to use\n */\nvar typeMap = {\n  HS256: 'hmac',\n  HS384: 'hmac',\n  HS512: 'hmac',\n  RS256: 'sign'\n};\n\n/**\n * expose object\n */\nvar jwt = module.exports;\n\n/**\n * version\n */\njwt.version = '0.5.6';\n\n/**\n * Decode jwt\n *\n * @param {Object} token\n * @param {String} key\n * @param {Boolean} [noVerify]\n * @param {String} [algorithm]\n * @return {Object} payload\n * @api public\n */\njwt.decode = function jwt_decode(token, key, noVerify, algorithm) {\n  // check token\n  if (!token) {\n    throw new Error('No token supplied');\n  }\n  // check segments\n  var segments = token.split('.');\n  if (segments.length !== 3) {\n    throw new Error('Not enough or too many segments');\n  }\n\n  // All segment should be base64\n  var headerSeg = segments[0];\n  var payloadSeg = segments[1];\n  var signatureSeg = segments[2];\n\n  // base64 decode and parse JSON\n  var header = JSON.parse(base64urlDecode(headerSeg));\n  var payload = JSON.parse(base64urlDecode(payloadSeg));\n  if (!noVerify) {\n    if (!algorithm && /BEGIN( RSA)? PUBLIC KEY/.test(key.toString())) {\n      algorithm = 'RS256';\n    }\n    var signingMethod = algorithmMap[algorithm || header.alg];\n    var signingType = typeMap[algorithm || header.alg];\n    if (!signingMethod || !signingType) {\n      throw new Error('Algorithm not supported');\n    }\n\n    // verify signature. `sign` will return base64 string.\n    var signingInput = [headerSeg, payloadSeg].join('.');\n    if (!verify(signingInput, key, signingMethod, signingType, signatureSeg)) {\n      throw new Error('Signature verification failed');\n    }\n\n    // Support for nbf and exp claims.\n    // According to the RFC, they should be in seconds.\n    if (payload.nbf && Date.now() < payload.nbf * 1000) {\n      throw new Error('Token not yet active');\n    }\n    if (payload.exp && Date.now() > payload.exp * 1000) {\n      throw new Error('Token expired');\n    }\n  }\n  return payload;\n};\n\n/**\n * Encode jwt\n *\n * @param {Object} payload\n * @param {String} key\n * @param {String} algorithm\n * @param {Object} options\n * @return {String} token\n * @api public\n */\njwt.encode = function jwt_encode(payload, key, algorithm, options) {\n  // Check key\n  if (!key) {\n    throw new Error('Require key');\n  }\n\n  // Check algorithm, default is HS256\n  if (!algorithm) {\n    algorithm = 'HS256';\n  }\n  var signingMethod = algorithmMap[algorithm];\n  var signingType = typeMap[algorithm];\n  if (!signingMethod || !signingType) {\n    throw new Error('Algorithm not supported');\n  }\n\n  // header, typ is fixed value.\n  var header = {\n    typ: 'JWT',\n    alg: algorithm\n  };\n  if (options && options.header) {\n    assignProperties(header, options.header);\n  }\n\n  // create segments, all segments should be base64 string\n  var segments = [];\n  segments.push(base64urlEncode(JSON.stringify(header)));\n  segments.push(base64urlEncode(JSON.stringify(payload)));\n  segments.push(sign(segments.join('.'), key, signingMethod, signingType));\n  return segments.join('.');\n};\n\n/**\n * private util functions\n */\n\nfunction assignProperties(dest, source) {\n  for (var attr in source) {\n    if (source.hasOwnProperty(attr)) {\n      dest[attr] = source[attr];\n    }\n  }\n}\nfunction verify(input, key, method, type, signature) {\n  if (type === \"hmac\") {\n    return signature === sign(input, key, method, type);\n  } else if (type == \"sign\") {\n    return crypto.createVerify(method).update(input).verify(key, base64urlUnescape(signature), 'base64');\n  } else {\n    throw new Error('Algorithm type not recognized');\n  }\n}\nfunction sign(input, key, method, type) {\n  var base64str;\n  if (type === \"hmac\") {\n    base64str = crypto.createHmac(method, key).update(input).digest('base64');\n  } else if (type == \"sign\") {\n    base64str = crypto.createSign(method).update(input).sign(key, 'base64');\n  } else {\n    throw new Error('Algorithm type not recognized');\n  }\n  return base64urlEscape(base64str);\n}\nfunction base64urlDecode(str) {\n  return Buffer.from(base64urlUnescape(str), 'base64').toString();\n}\nfunction base64urlUnescape(str) {\n  str += new Array(5 - str.length % 4).join('=');\n  return str.replace(/\\-/g, '+').replace(/_/g, '/');\n}\nfunction base64urlEncode(str) {\n  return base64urlEscape(Buffer.from(str).toString('base64'));\n}\nfunction base64urlEscape(str) {\n  return str.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}","map":{"version":3,"names":["crypto","require","algorithmMap","HS256","HS384","HS512","RS256","typeMap","jwt","module","exports","version","decode","jwt_decode","token","key","noVerify","algorithm","Error","segments","split","length","headerSeg","payloadSeg","signatureSeg","header","JSON","parse","base64urlDecode","payload","test","toString","signingMethod","alg","signingType","signingInput","join","verify","nbf","Date","now","exp","encode","jwt_encode","options","typ","assignProperties","push","base64urlEncode","stringify","sign","dest","source","attr","hasOwnProperty","input","method","type","signature","createVerify","update","base64urlUnescape","base64str","createHmac","digest","createSign","base64urlEscape","str","Buffer","from","Array","replace"],"sources":["/Users/v450/myphysiotherapist/node_modules/jwt-simple/lib/jwt.js"],"sourcesContent":["/*\n * jwt-simple\n *\n * JSON Web Token encode and decode module for node.js\n *\n * Copyright(c) 2011 Kazuhito Hokamura\n * MIT Licensed\n */\n\n/**\n * module dependencies\n */\nvar crypto = require('crypto');\n\n\n/**\n * support algorithm mapping\n */\nvar algorithmMap = {\n  HS256: 'sha256',\n  HS384: 'sha384',\n  HS512: 'sha512',\n  RS256: 'RSA-SHA256'\n};\n\n/**\n * Map algorithm to hmac or sign type, to determine which crypto function to use\n */\nvar typeMap = {\n  HS256: 'hmac',\n  HS384: 'hmac',\n  HS512: 'hmac',\n  RS256: 'sign'\n};\n\n\n/**\n * expose object\n */\nvar jwt = module.exports;\n\n\n/**\n * version\n */\njwt.version = '0.5.6';\n\n/**\n * Decode jwt\n *\n * @param {Object} token\n * @param {String} key\n * @param {Boolean} [noVerify]\n * @param {String} [algorithm]\n * @return {Object} payload\n * @api public\n */\njwt.decode = function jwt_decode(token, key, noVerify, algorithm) {\n  // check token\n  if (!token) {\n    throw new Error('No token supplied');\n  }\n  // check segments\n  var segments = token.split('.');\n  if (segments.length !== 3) {\n    throw new Error('Not enough or too many segments');\n  }\n\n  // All segment should be base64\n  var headerSeg = segments[0];\n  var payloadSeg = segments[1];\n  var signatureSeg = segments[2];\n\n  // base64 decode and parse JSON\n  var header = JSON.parse(base64urlDecode(headerSeg));\n  var payload = JSON.parse(base64urlDecode(payloadSeg));\n\n  if (!noVerify) {\n    if (!algorithm && /BEGIN( RSA)? PUBLIC KEY/.test(key.toString())) {\n      algorithm = 'RS256';\n    }\n\n    var signingMethod = algorithmMap[algorithm || header.alg];\n    var signingType = typeMap[algorithm || header.alg];\n    if (!signingMethod || !signingType) {\n      throw new Error('Algorithm not supported');\n    }\n\n    // verify signature. `sign` will return base64 string.\n    var signingInput = [headerSeg, payloadSeg].join('.');\n    if (!verify(signingInput, key, signingMethod, signingType, signatureSeg)) {\n      throw new Error('Signature verification failed');\n    }\n\n    // Support for nbf and exp claims.\n    // According to the RFC, they should be in seconds.\n    if (payload.nbf && Date.now() < payload.nbf*1000) {\n      throw new Error('Token not yet active');\n    }\n\n    if (payload.exp && Date.now() > payload.exp*1000) {\n      throw new Error('Token expired');\n    }\n  }\n\n  return payload;\n};\n\n\n/**\n * Encode jwt\n *\n * @param {Object} payload\n * @param {String} key\n * @param {String} algorithm\n * @param {Object} options\n * @return {String} token\n * @api public\n */\njwt.encode = function jwt_encode(payload, key, algorithm, options) {\n  // Check key\n  if (!key) {\n    throw new Error('Require key');\n  }\n\n  // Check algorithm, default is HS256\n  if (!algorithm) {\n    algorithm = 'HS256';\n  }\n\n  var signingMethod = algorithmMap[algorithm];\n  var signingType = typeMap[algorithm];\n  if (!signingMethod || !signingType) {\n    throw new Error('Algorithm not supported');\n  }\n\n  // header, typ is fixed value.\n  var header = { typ: 'JWT', alg: algorithm };\n  if (options && options.header) {\n    assignProperties(header, options.header);\n  }\n\n  // create segments, all segments should be base64 string\n  var segments = [];\n  segments.push(base64urlEncode(JSON.stringify(header)));\n  segments.push(base64urlEncode(JSON.stringify(payload)));\n  segments.push(sign(segments.join('.'), key, signingMethod, signingType));\n\n  return segments.join('.');\n};\n\n/**\n * private util functions\n */\n\nfunction assignProperties(dest, source) {\n  for (var attr in source) {\n    if (source.hasOwnProperty(attr)) {\n      dest[attr] = source[attr];\n    }\n  }\n}\n\nfunction verify(input, key, method, type, signature) {\n  if(type === \"hmac\") {\n    return (signature === sign(input, key, method, type));\n  }\n  else if(type == \"sign\") {\n    return crypto.createVerify(method)\n                 .update(input)\n                 .verify(key, base64urlUnescape(signature), 'base64');\n  }\n  else {\n    throw new Error('Algorithm type not recognized');\n  }\n}\n\nfunction sign(input, key, method, type) {\n  var base64str;\n  if(type === \"hmac\") {\n    base64str = crypto.createHmac(method, key).update(input).digest('base64');\n  }\n  else if(type == \"sign\") {\n    base64str = crypto.createSign(method).update(input).sign(key, 'base64');\n  }\n  else {\n    throw new Error('Algorithm type not recognized');\n  }\n\n  return base64urlEscape(base64str);\n}\n\nfunction base64urlDecode(str) {\n  return Buffer.from(base64urlUnescape(str), 'base64').toString();\n}\n\nfunction base64urlUnescape(str) {\n  str += new Array(5 - str.length % 4).join('=');\n  return str.replace(/\\-/g, '+').replace(/_/g, '/');\n}\n\nfunction base64urlEncode(str) {\n  return base64urlEscape(Buffer.from(str).toString('base64'));\n}\n\nfunction base64urlEscape(str) {\n  return str.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;;AAG9B;AACA;AACA;AACA,IAAIC,YAAY,GAAG;EACjBC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE;AACT,CAAC;;AAED;AACA;AACA;AACA,IAAIC,OAAO,GAAG;EACZJ,KAAK,EAAE,MAAM;EACbC,KAAK,EAAE,MAAM;EACbC,KAAK,EAAE,MAAM;EACbC,KAAK,EAAE;AACT,CAAC;;AAGD;AACA;AACA;AACA,IAAIE,GAAG,GAAGC,MAAM,CAACC,OAAO;;AAGxB;AACA;AACA;AACAF,GAAG,CAACG,OAAO,GAAG,OAAO;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,GAAG,CAACI,MAAM,GAAG,SAASC,UAAUA,CAACC,KAAK,EAAEC,GAAG,EAAEC,QAAQ,EAAEC,SAAS,EAAE;EAChE;EACA,IAAI,CAACH,KAAK,EAAE;IACV,MAAM,IAAII,KAAK,CAAC,mBAAmB,CAAC;EACtC;EACA;EACA,IAAIC,QAAQ,GAAGL,KAAK,CAACM,KAAK,CAAC,GAAG,CAAC;EAC/B,IAAID,QAAQ,CAACE,MAAM,KAAK,CAAC,EAAE;IACzB,MAAM,IAAIH,KAAK,CAAC,iCAAiC,CAAC;EACpD;;EAEA;EACA,IAAII,SAAS,GAAGH,QAAQ,CAAC,CAAC,CAAC;EAC3B,IAAII,UAAU,GAAGJ,QAAQ,CAAC,CAAC,CAAC;EAC5B,IAAIK,YAAY,GAAGL,QAAQ,CAAC,CAAC,CAAC;;EAE9B;EACA,IAAIM,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACC,eAAe,CAACN,SAAS,CAAC,CAAC;EACnD,IAAIO,OAAO,GAAGH,IAAI,CAACC,KAAK,CAACC,eAAe,CAACL,UAAU,CAAC,CAAC;EAErD,IAAI,CAACP,QAAQ,EAAE;IACb,IAAI,CAACC,SAAS,IAAI,yBAAyB,CAACa,IAAI,CAACf,GAAG,CAACgB,QAAQ,CAAC,CAAC,CAAC,EAAE;MAChEd,SAAS,GAAG,OAAO;IACrB;IAEA,IAAIe,aAAa,GAAG9B,YAAY,CAACe,SAAS,IAAIQ,MAAM,CAACQ,GAAG,CAAC;IACzD,IAAIC,WAAW,GAAG3B,OAAO,CAACU,SAAS,IAAIQ,MAAM,CAACQ,GAAG,CAAC;IAClD,IAAI,CAACD,aAAa,IAAI,CAACE,WAAW,EAAE;MAClC,MAAM,IAAIhB,KAAK,CAAC,yBAAyB,CAAC;IAC5C;;IAEA;IACA,IAAIiB,YAAY,GAAG,CAACb,SAAS,EAAEC,UAAU,CAAC,CAACa,IAAI,CAAC,GAAG,CAAC;IACpD,IAAI,CAACC,MAAM,CAACF,YAAY,EAAEpB,GAAG,EAAEiB,aAAa,EAAEE,WAAW,EAAEV,YAAY,CAAC,EAAE;MACxE,MAAM,IAAIN,KAAK,CAAC,+BAA+B,CAAC;IAClD;;IAEA;IACA;IACA,IAAIW,OAAO,CAACS,GAAG,IAAIC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGX,OAAO,CAACS,GAAG,GAAC,IAAI,EAAE;MAChD,MAAM,IAAIpB,KAAK,CAAC,sBAAsB,CAAC;IACzC;IAEA,IAAIW,OAAO,CAACY,GAAG,IAAIF,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGX,OAAO,CAACY,GAAG,GAAC,IAAI,EAAE;MAChD,MAAM,IAAIvB,KAAK,CAAC,eAAe,CAAC;IAClC;EACF;EAEA,OAAOW,OAAO;AAChB,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArB,GAAG,CAACkC,MAAM,GAAG,SAASC,UAAUA,CAACd,OAAO,EAAEd,GAAG,EAAEE,SAAS,EAAE2B,OAAO,EAAE;EACjE;EACA,IAAI,CAAC7B,GAAG,EAAE;IACR,MAAM,IAAIG,KAAK,CAAC,aAAa,CAAC;EAChC;;EAEA;EACA,IAAI,CAACD,SAAS,EAAE;IACdA,SAAS,GAAG,OAAO;EACrB;EAEA,IAAIe,aAAa,GAAG9B,YAAY,CAACe,SAAS,CAAC;EAC3C,IAAIiB,WAAW,GAAG3B,OAAO,CAACU,SAAS,CAAC;EACpC,IAAI,CAACe,aAAa,IAAI,CAACE,WAAW,EAAE;IAClC,MAAM,IAAIhB,KAAK,CAAC,yBAAyB,CAAC;EAC5C;;EAEA;EACA,IAAIO,MAAM,GAAG;IAAEoB,GAAG,EAAE,KAAK;IAAEZ,GAAG,EAAEhB;EAAU,CAAC;EAC3C,IAAI2B,OAAO,IAAIA,OAAO,CAACnB,MAAM,EAAE;IAC7BqB,gBAAgB,CAACrB,MAAM,EAAEmB,OAAO,CAACnB,MAAM,CAAC;EAC1C;;EAEA;EACA,IAAIN,QAAQ,GAAG,EAAE;EACjBA,QAAQ,CAAC4B,IAAI,CAACC,eAAe,CAACtB,IAAI,CAACuB,SAAS,CAACxB,MAAM,CAAC,CAAC,CAAC;EACtDN,QAAQ,CAAC4B,IAAI,CAACC,eAAe,CAACtB,IAAI,CAACuB,SAAS,CAACpB,OAAO,CAAC,CAAC,CAAC;EACvDV,QAAQ,CAAC4B,IAAI,CAACG,IAAI,CAAC/B,QAAQ,CAACiB,IAAI,CAAC,GAAG,CAAC,EAAErB,GAAG,EAAEiB,aAAa,EAAEE,WAAW,CAAC,CAAC;EAExE,OAAOf,QAAQ,CAACiB,IAAI,CAAC,GAAG,CAAC;AAC3B,CAAC;;AAED;AACA;AACA;;AAEA,SAASU,gBAAgBA,CAACK,IAAI,EAAEC,MAAM,EAAE;EACtC,KAAK,IAAIC,IAAI,IAAID,MAAM,EAAE;IACvB,IAAIA,MAAM,CAACE,cAAc,CAACD,IAAI,CAAC,EAAE;MAC/BF,IAAI,CAACE,IAAI,CAAC,GAAGD,MAAM,CAACC,IAAI,CAAC;IAC3B;EACF;AACF;AAEA,SAAShB,MAAMA,CAACkB,KAAK,EAAExC,GAAG,EAAEyC,MAAM,EAAEC,IAAI,EAAEC,SAAS,EAAE;EACnD,IAAGD,IAAI,KAAK,MAAM,EAAE;IAClB,OAAQC,SAAS,KAAKR,IAAI,CAACK,KAAK,EAAExC,GAAG,EAAEyC,MAAM,EAAEC,IAAI,CAAC;EACtD,CAAC,MACI,IAAGA,IAAI,IAAI,MAAM,EAAE;IACtB,OAAOzD,MAAM,CAAC2D,YAAY,CAACH,MAAM,CAAC,CACpBI,MAAM,CAACL,KAAK,CAAC,CACblB,MAAM,CAACtB,GAAG,EAAE8C,iBAAiB,CAACH,SAAS,CAAC,EAAE,QAAQ,CAAC;EACnE,CAAC,MACI;IACH,MAAM,IAAIxC,KAAK,CAAC,+BAA+B,CAAC;EAClD;AACF;AAEA,SAASgC,IAAIA,CAACK,KAAK,EAAExC,GAAG,EAAEyC,MAAM,EAAEC,IAAI,EAAE;EACtC,IAAIK,SAAS;EACb,IAAGL,IAAI,KAAK,MAAM,EAAE;IAClBK,SAAS,GAAG9D,MAAM,CAAC+D,UAAU,CAACP,MAAM,EAAEzC,GAAG,CAAC,CAAC6C,MAAM,CAACL,KAAK,CAAC,CAACS,MAAM,CAAC,QAAQ,CAAC;EAC3E,CAAC,MACI,IAAGP,IAAI,IAAI,MAAM,EAAE;IACtBK,SAAS,GAAG9D,MAAM,CAACiE,UAAU,CAACT,MAAM,CAAC,CAACI,MAAM,CAACL,KAAK,CAAC,CAACL,IAAI,CAACnC,GAAG,EAAE,QAAQ,CAAC;EACzE,CAAC,MACI;IACH,MAAM,IAAIG,KAAK,CAAC,+BAA+B,CAAC;EAClD;EAEA,OAAOgD,eAAe,CAACJ,SAAS,CAAC;AACnC;AAEA,SAASlC,eAAeA,CAACuC,GAAG,EAAE;EAC5B,OAAOC,MAAM,CAACC,IAAI,CAACR,iBAAiB,CAACM,GAAG,CAAC,EAAE,QAAQ,CAAC,CAACpC,QAAQ,CAAC,CAAC;AACjE;AAEA,SAAS8B,iBAAiBA,CAACM,GAAG,EAAE;EAC9BA,GAAG,IAAI,IAAIG,KAAK,CAAC,CAAC,GAAGH,GAAG,CAAC9C,MAAM,GAAG,CAAC,CAAC,CAACe,IAAI,CAAC,GAAG,CAAC;EAC9C,OAAO+B,GAAG,CAACI,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;AACnD;AAEA,SAASvB,eAAeA,CAACmB,GAAG,EAAE;EAC5B,OAAOD,eAAe,CAACE,MAAM,CAACC,IAAI,CAACF,GAAG,CAAC,CAACpC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AAC7D;AAEA,SAASmC,eAAeA,CAACC,GAAG,EAAE;EAC5B,OAAOA,GAAG,CAACI,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;AACtE","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}